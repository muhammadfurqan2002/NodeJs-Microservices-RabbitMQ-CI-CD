/**
 * This file is generated by @ioredis/interface-generator.
 * Don't edit it manually. Instead, run `npm run generate` to update
 * this file.
 */
/// <reference types="node" />
import { Callback } from "../types";
export declare type RedisKey = string | Buffer;
export declare type RedisValue = string | Buffer | number;
export interface ResultTypes<Result, Context> {
    default: Promise<Result>;
    pipeline: ChainableCommander;
}
export interface ChainableCommander extends RedisCommander<{
    type: "pipeline";
}> {
    length: number;
}
export declare type ClientContext = {
    type: keyof ResultTypes<unknown, unknown>;
};
export declare type Result<T, Context extends ClientContext> = ResultTypes<T, Context>[Context["type"]];
interface RedisCommander<Context extends ClientContext = {
    type: "default";
}> {
    /**
     * Call arbitrary commands.
     *
     * `redis.call('set', 'foo', 'bar')` is the same as `redis.set('foo', 'bar')`,
     * so the only case you need to use this method is when the command is not
     * supported by ioredis.
     *
     * ```ts
     * redis.call('set', 'foo', 'bar');
     * redis.call('get', 'foo', (err, value) => {
     *   // value === 'bar'
     * });
     * ```
     */
    call(command: string, callback?: Callback<unknown>): Result<unknown, Context>;
    call(command: string, args: (string | Buffer | number)[], callback?: Callback<unknown>): Result<unknown, Context>;
    call(...args: [
        command: string,
        ...args: (string | Buffer | number)[],
        callback: Callback<unknown>
    ]): Result<unknown, Context>;
    call(...args: [command: string, ...args: (string | Buffer | number)[]]): Result<unknown, Context>;
    callBuffer(command: string, callback?: Callback<unknown>): Result<unknown, Context>;
    callBuffer(command: string, args: (string | Buffer | number)[], callback?: Callback<unknown>): Result<unknown, Context>;
    callBuffer(...args: [
        command: string,
        ...args: (string | Buffer | number)[],
        callback: Callback<unknown>
    ]): Result<unknown, Context>;
    callBuffer(...args: [command: string, ...args: (string | Buffer | number)[]]): Result<unknown, Context>;
    /**
     * List the ACL categories or the commands inside a category
     * - _group_: server
     * - _complexity_: O(1) since the categories and commands are a fixed set.
     * - _since_: 6.0.0
     */
    acl(subcommand: "CAT", callback?: Callback<unknown>): Result<unknown, Context>;
    acl(subcommand: "CAT", categoryname: string | Buffer, callback?: Callback<unknown>): Result<unknown, Context>;
    /**
     * Remove the specified ACL users and the associated rules
     * - _group_: server
     * - _complexity_: O(1) amortized time considering the typical user.
     * - _since_: 6.0.0
     */
    acl(...args: [
        subcommand: "DELUSER",
        ...usernames: (string | Buffer)[],
        callback: Callback<number>
    ]): Result<number, Context>;
    acl(...args: [subcommand: "DELUSER", ...usernames: (string | Buffer)[]]): Result<number, Context>;
    /**
     * Returns whether the user can execute the given command without executing the command.
     * - _group_: server
     * - _complexity_: O(1).
     * - _since_: 7.0.0
     */
    acl(subcommand: "DRYRUN", username: string | Buffer, command: string | Buffer, callback?: Callback<string>): Result<string, Context>;
    aclBuffer(subcommand: "DRYRUN", username: string | Buffer, command: string | Buffer, callback?: Callback<Buffer>): Result<Buffer, Context>;
    acl(...args: [
        subcommand: "DRYRUN",
        username: string | Buffer,
        command: string | Buffer,
        ...args: (string | Buffer | number)[],
        callback: Callback<string>
    ]): Result<string, Context>;
    aclBuffer(...args: [
        subcommand: "DRYRUN",
        username: string | Buffer,
        command: string | Buffer,
        ...args: (string | Buffer | number)[],
        callback: Callback<Buffer>
    ]): Result<Buffer, Context>;
    acl(...args: [
        subcommand: "DRYRUN",
        username: string | Buffer,
        command: string | Buffer,
        ...args: (string | Buffer | number)[]
    ]): Result<string, Context>;
    aclBuffer(...args: [
        subcommand: "DRYRUN",
        username: string | Buffer,
        command: string | Buffer,
        ...args: (string | Buffer | number)[]
    ]): Result<Buffer, Context>;
    /**
     * Generate a pseudorandom secure password to use for ACL users
     * - _group_: server
     * - _complexity_: O(1)
     * - _since_: 6.0.0
     */
    acl(subcommand: "GENPASS", callback?: Callback<string>): Result<string, Context>;
    aclBuffer(subcommand: "GENPASS", callback?: Callback<Buffer>): Result<Buffer, Context>;
    acl(subcommand: "GENPASS", bits: number | string, callback?: Callback<string>): Result<string, Context>;
    aclBuffer(subcommand: "GENPASS", bits: number | string, callback?: Callback<Buffer>): Result<Buffer, Context>;
    /**
     * Get the rules for a specific ACL user
     * - _group_: server
     * - _complexity_: O(N). Where N is the number of password, command and pattern rules that the user has.
     * - _since_: 6.0.0
     */
    acl(subcommand: "GETUSER", username: string | Buffer, callback?: Callback<string[] | null>): Result<string[] | null, Context>;
    aclBuffer(subcommand: "GETUSER", username: string | Buffer, callback?: Callback<Buffer[] | null>): Result<Buffer[] | null, Context>;
    /**
     * Show helpful text about the different subcommands
     * - _group_: server
     * - _complexity_: O(1)
     * - _since_: 6.0.0
     */
    acl(subcommand: "HELP", callback?: Callback<unknown>): Result<unknown, Context>;
    /**
     * List the current ACL rules in ACL config file format
     * - _group_: server
     * - _complexity_: O(N). Where N is the number of configured users.
     * - _since_: 6.0.0
     */
    acl(subcommand: "LIST", callback?: Callback<string[]>): Result<string[], Context>;
    aclBuffer(subcommand: "LIST", callback?: Callback<Buffer[]>): Result<Buffer[], Context>;
    /**
     * Reload the ACLs from the configured ACL file
     * - _group_: server
     * - _complexity_: O(N). Where N is the number of configured users.
     * - _since_: 6.0.0
     */
    acl(subcommand: "LOAD", callback?: Callback<"OK">): Result<"OK", Context>;
    /**
     * List latest events denied because of ACLs in place
     * - _group_: server
     * - _complexity_: O(N) with N being the number of entries shown.
     * - _since_: 6.0.0
     */
    acl(subcommand: "LOG", callback?: Callback<unknown>): Result<unknown, Context>;
    acl(subcommand: "LOG", count: number | string, callback?: Callback<unknown>): Result<unknown, Context>;
    acl(subcommand: "LOG", reset: "RESET", callback?: Callback<unknown>): Result<unknown, Context>;
    /**
     * Save the current ACL rules in the configured ACL file
     * - _group_: server
     * - _complexity_: O(N). Where N is the number of configured users.
     * - _since_: 6.0.0
     */
    acl(subcommand: "SAVE", callback?: Callback<"OK">): Result<"OK", Context>;
    /**
     * Modify or create the rules for a specific ACL user
     * - _group_: server
     * - _complexity_: O(N). Where N is the number of rules provided.
     * - _since_: 6.0.0
     */
    acl(subcommand: "SETUSER", username: string | Buffer, callback?: Callback<"OK">): Result<"OK", Context>;
    acl(...args: [
        subcommand: "SETUSER",
        username: string | Buffer,
        ...rules: (string | Buffer)[],
        callback: Callback<"OK">
    ]): Result<"OK", Context>;
    acl(...args: [
        subcommand: "SETUSER",
        username: string | Buffer,
        ...rules: (string | Buffer)[]
    ]): Result<"OK", Context>;
    /**
     * List the username of all the configured ACL rules
     * - _group_: server
     * - _complexity_: O(N). Where N is the number of configured users.
     * - _since_: 6.0.0
     */
    acl(subcommand: "USERS", callback?: Callback<string[]>): Result<string[], Context>;
    aclBuffer(subcommand: "USERS", callback?: Callback<Buffer[]>): Result<Buffer[], Context>;
    /**
     * Return the name of the user associated to the current connection
     * - _group_: server
     * - _complexity_: O(1)
     * - _since_: 6.0.0
     */
    acl(subcommand: "WHOAMI", callback?: Callback<string>): Result<string, Context>;
    aclBuffer(subcommand: "WHOAMI", callback?: Callback<Buffer>): Result<Buffer, Context>;
    /**
     * Append a value to a key
     * - _group_: string
     * - _complexity_: O(1). The amortized time complexity is O(1) assuming the appended value is small and the already present value is of any size, since the dynamic string library used by Redis will double the free space available on every reallocation.
     * - _since_: 2.0.0
     */
    append(key: RedisKey, value: string | Buffer | number, callback?: Callback<number>): Result<number, Context>;
    /**
     * Sent by cluster clients after an -ASK redirect
     * - _group_: cluster
     * - _complexity_: O(1)
     * - _since_: 3.0.0
     */
    asking(callback?: Callback<"OK">): Result<"OK", Context>;
    /**
     * Authenticate to the server
     * - _group_: connection
     * - _complexity_: O(N) where N is the number of passwords defined for the user
     * - _since_: 1.0.0
     */
    auth(password: string | Buffer, callback?: Callback<"OK">): Result<"OK", Context>;
    auth(username: string | Buffer, password: string | Buffer, callback?: Callback<"OK">): Result<"OK", Context>;
    /**
     * Asynchronously rewrite the append-only file
     * - _group_: server
     * - _complexity_: O(1)
     * - _since_: 1.0.0
     */
    bgrewriteaof(callback?: Callback<string>): Result<string, Context>;
    bgrewriteaofBuffer(callback?: Callback<Buffer>): Result<Buffer, Context>;
    /**
     * Asynchronously save the dataset to disk
     * - _group_: server
     * - _complexity_: O(1)
     * - _since_: 1.0.0
     */
    bgsave(callback?: Callback<"OK">): Result<"OK", Context>;
    bgsave(schedule: "SCHEDULE", callback?: Callback<"OK">): Result<"OK", Context>;
    /**
     * Count set bits in a string
     * - _group_: bitmap
     * - _complexity_: O(N)
     * - _since_: 2.6.0
     */
    bitcount(key: RedisKey, callback?: Callback<number>): Result<number, Context>;
    bitcount(key: RedisKey, start: number | string, end: number | string, callback?: Callback<number>): Result<number, Context>;
    bitcount(key: RedisKey, start: number | string, end: number | string, byte: "BYTE", callback?: Callback<number>): Result<number, Context>;
    bitcount(key: RedisKey, start: number | string, end: number | string, bit: "BIT", callback?: Callback<number>): Result<number, Context>;
    /**
     * Perform arbitrary bitfield integer operations on strings
     * - _group_: bitmap
     * - _complexity_: O(1) for each subcommand specified
     * - _since_: 3.2.0
     */
    bitfield(key: RedisKey, encodingOffsetToken: "GET", encoding: string | Buffer, offset: number | string, callback?: Callback<unknown>): Result<unknown, Context>;
    bitfield(key: RedisKey, encodingOffsetValueToken: "SET", encoding: string | Buffer, offset: number | string, value: number | string, callback?: Callback<unknown>): Result<unknown, Context>;
    bitfield(key: RedisKey, encodingOffsetIncrementToken: "INCRBY", encoding: string | Buffer, offset: number | string, increment: number | string, callback?: Callback<unknown>): Result<unknown, Context>;
    bitfield(key: RedisKey, overflow: "OVERFLOW", wrap: "WRAP", encodingOffsetValueToken: "SET", encoding: string | Buffer, offset: number | string, value: number | string, callback?: Callback<unknown>): Result<unknown, Context>;
    bitfield(key: RedisKey, overflow: "OVERFLOW", wrap: "WRAP", encodingOffsetIncrementToken: "INCRBY", encoding: string | Buffer, offset: number | string, increment: number | string, callback?: Callback<unknown>): Result<unknown, Context>;
    bitfield(key: RedisKey, overflow: "OVERFLOW", sat: "SAT", encodingOffsetValueToken: "SET", encoding: string | Buffer, offset: number | string, value: number | string, callback?: Callback<unknown>): Result<unknown, Context>;
    bitfield(key: RedisKey, overflow: "OVERFLOW", sat: "SAT", encodingOffsetIncrementToken: "INCRBY", encoding: string | Buffer, offset: number | string, increment: number | string, callback?: Callback<unknown>): Result<unknown, Context>;
    bitfield(key: RedisKey, overflow: "OVERFLOW", fail: "FAIL", encodingOffsetValueToken: "SET", encoding: string | Buffer, offset: number | string, value: number | string, callback?: Callback<unknown>): Result<unknown, Context>;
    bitfield(key: RedisKey, overflow: "OVERFLOW", fail: "FAIL", encodingOffsetIncrementToken: "INCRBY", encoding: string | Buffer, offset: number | string, increment: number | string, callback?: Callback<unknown>): Result<unknown, Context>;
    /**
     * Perform arbitrary bitfield integer operations on strings. Read-only variant of BITFIELD
     * - _group_: bitmap
     * - _complexity_: O(1) for each subcommand specified
     * - _since_: 6.0.0
     */
    bitfield_ro(...args: [
        key: RedisKey,
        encodingOffsetToken: "GET",
        ...encodingOffsets: (string | Buffer | number)[],
        callback: Callback<unknown[]>
    ]): Result<unknown[], Context>;
    bitfield_ro(...args: [
        key: RedisKey,
        encodingOffsetToken: "GET",
        ...encodingOffsets: (string | Buffer | number)[]
    ]): Result<unknown[], Context>;
    /**
     * Perform bitwise operations between strings
     * - _group_: bitmap
     * - _complexity_: O(N)
     * - _since_: 2.6.0
     */
    bitop(...args: [
        operation: string | Buffer,
        destkey: RedisKey,
        ...keys: RedisKey[],
        callback: Callback<number>
    ]): Result<number, Context>;
    bitop(...args: [
        operation: string | Buffer,
        destkey: RedisKey,
        keys: RedisKey[],
        callback: Callback<number>
    ]): Result<number, Context>;
    bitop(...args: [
        operation: string | Buffer,
        destkey: RedisKey,
        ...keys: RedisKey[]
    ]): Result<number, Context>;
    bitop(...args: [operation: string | Buffer, destkey: RedisKey, keys: RedisKey[]]): Result<number, Context>;
    /**
     * Find first bit set or clear in a string
     * - _group_: bitmap
     * - _complexity_: O(N)
     * - _since_: 2.8.7
     */
    bitpos(key: RedisKey, bit: number | string, callback?: Callback<number>): Result<number, Context>;
    bitpos(key: RedisKey, bit: number | string, start: number | string, callback?: Callback<number>): Result<number, Context>;
    bitpos(key: RedisKey, bit: number | string, start: number | string, end: number | string, callback?: Callback<number>): Result<number, Context>;
    bitpos(key: RedisKey, bit: number | string, start: number | string, end: number | string, byte: "BYTE", callback?: Callback<number>): Result<number, Context>;
    bitpos(key: RedisKey, bit: number | string, start: number | string, end: number | string, bit1: "BIT", callback?: Callback<number>): Result<number, Context>;
    /**
     * Pop an element from a list, push it to another list and return it; or block until one is available
     * - _group_: list
     * - _complexity_: O(1)
     * - _since_: 6.2.0
     */
    blmove(source: RedisKey, destination: RedisKey, left: "LEFT", left1: "LEFT", timeout: number | string, callback?: Callback<string | null>): Result<string | null, Context>;
    blmoveBuffer(source: RedisKey, destination: RedisKey, left: "LEFT", left1: "LEFT", timeout: number | string, callback?: Callback<Buffer | null>): Result<Buffer | null, Context>;
    blmove(source: RedisKey, destination: RedisKey, left: "LEFT", right: "RIGHT", timeout: number | string, callback?: Callback<string | null>): Result<string | null, Context>;
    blmoveBuffer(source: RedisKey, destination: RedisKey, left: "LEFT", right: "RIGHT", timeout: number | string, callback?: Callback<Buffer | null>): Result<Buffer | null, Context>;
    blmove(source: RedisKey, destination: RedisKey, right: "RIGHT", left: "LEFT", timeout: number | string, callback?: Callback<string | null>): Result<string | null, Context>;
    blmoveBuffer(source: RedisKey, destination: RedisKey, right: "RIGHT", left: "LEFT", timeout: number | string, callback?: Callback<Buffer | null>): Result<Buffer | null, Context>;
    blmove(source: RedisKey, destination: RedisKey, right: "RIGHT", right1: "RIGHT", timeout: number | string, callback?: Callback<string | null>): Result<string | null, Context>;
    blmoveBuffer(source: RedisKey, destination: RedisKey, right: "RIGHT", right1: "RIGHT", timeout: number | string, callback?: Callback<Buffer | null>): Result<Buffer | null, Context>;
    /**
     * Pop elements from a list, or block until one is available
     * - _group_: list
     * - _complexity_: O(N+M) where N is the number of provided keys and M is the number of elements returned.
     * - _since_: 7.0.0
     */
    blmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        left: "LEFT",
        callback: Callback<[key: string, members: string[]] | null>
    ]): Result<[key: string, members: string[]] | null, Context>;
    blmpopBuffer(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        left: "LEFT",
        callback: Callback<[key: Buffer, members: Buffer[]] | null>
    ]): Result<[key: Buffer, members: Buffer[]] | null, Context>;
    blmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        left: "LEFT",
        callback: Callback<[key: string, members: string[]] | null>
    ]): Result<[key: string, members: string[]] | null, Context>;
    blmpopBuffer(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        left: "LEFT",
        callback: Callback<[key: Buffer, members: Buffer[]] | null>
    ]): Result<[key: Buffer, members: Buffer[]] | null, Context>;
    blmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        left: "LEFT"
    ]): Result<[key: string, members: string[]] | null, Context>;
    blmpopBuffer(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        left: "LEFT"
    ]): Result<[key: Buffer, members: Buffer[]] | null, Context>;
    blmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        left: "LEFT"
    ]): Result<[key: string, members: string[]] | null, Context>;
    blmpopBuffer(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        left: "LEFT"
    ]): Result<[key: Buffer, members: Buffer[]] | null, Context>;
    blmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        left: "LEFT",
        countToken: "COUNT",
        count: number | string,
        callback: Callback<[key: string, members: string[]] | null>
    ]): Result<[key: string, members: string[]] | null, Context>;
    blmpopBuffer(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        left: "LEFT",
        countToken: "COUNT",
        count: number | string,
        callback: Callback<[key: Buffer, members: Buffer[]] | null>
    ]): Result<[key: Buffer, members: Buffer[]] | null, Context>;
    blmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        left: "LEFT",
        countToken: "COUNT",
        count: number | string,
        callback: Callback<[key: string, members: string[]] | null>
    ]): Result<[key: string, members: string[]] | null, Context>;
    blmpopBuffer(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        left: "LEFT",
        countToken: "COUNT",
        count: number | string,
        callback: Callback<[key: Buffer, members: Buffer[]] | null>
    ]): Result<[key: Buffer, members: Buffer[]] | null, Context>;
    blmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        left: "LEFT",
        countToken: "COUNT",
        count: number | string
    ]): Result<[key: string, members: string[]] | null, Context>;
    blmpopBuffer(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        left: "LEFT",
        countToken: "COUNT",
        count: number | string
    ]): Result<[key: Buffer, members: Buffer[]] | null, Context>;
    blmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        left: "LEFT",
        countToken: "COUNT",
        count: number | string
    ]): Result<[key: string, members: string[]] | null, Context>;
    blmpopBuffer(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        left: "LEFT",
        countToken: "COUNT",
        count: number | string
    ]): Result<[key: Buffer, members: Buffer[]] | null, Context>;
    blmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        right: "RIGHT",
        callback: Callback<[key: string, members: string[]] | null>
    ]): Result<[key: string, members: string[]] | null, Context>;
    blmpopBuffer(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        right: "RIGHT",
        callback: Callback<[key: Buffer, members: Buffer[]] | null>
    ]): Result<[key: Buffer, members: Buffer[]] | null, Context>;
    blmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        right: "RIGHT",
        callback: Callback<[key: string, members: string[]] | null>
    ]): Result<[key: string, members: string[]] | null, Context>;
    blmpopBuffer(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        right: "RIGHT",
        callback: Callback<[key: Buffer, members: Buffer[]] | null>
    ]): Result<[key: Buffer, members: Buffer[]] | null, Context>;
    blmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        right: "RIGHT"
    ]): Result<[key: string, members: string[]] | null, Context>;
    blmpopBuffer(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        right: "RIGHT"
    ]): Result<[key: Buffer, members: Buffer[]] | null, Context>;
    blmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        right: "RIGHT"
    ]): Result<[key: string, members: string[]] | null, Context>;
    blmpopBuffer(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        right: "RIGHT"
    ]): Result<[key: Buffer, members: Buffer[]] | null, Context>;
    blmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        right: "RIGHT",
        countToken: "COUNT",
        count: number | string,
        callback: Callback<[key: string, members: string[]] | null>
    ]): Result<[key: string, members: string[]] | null, Context>;
    blmpopBuffer(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        right: "RIGHT",
        countToken: "COUNT",
        count: number | string,
        callback: Callback<[key: Buffer, members: Buffer[]] | null>
    ]): Result<[key: Buffer, members: Buffer[]] | null, Context>;
    blmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        right: "RIGHT",
        countToken: "COUNT",
        count: number | string,
        callback: Callback<[key: string, members: string[]] | null>
    ]): Result<[key: string, members: string[]] | null, Context>;
    blmpopBuffer(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        right: "RIGHT",
        countToken: "COUNT",
        count: number | string,
        callback: Callback<[key: Buffer, members: Buffer[]] | null>
    ]): Result<[key: Buffer, members: Buffer[]] | null, Context>;
    blmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        right: "RIGHT",
        countToken: "COUNT",
        count: number | string
    ]): Result<[key: string, members: string[]] | null, Context>;
    blmpopBuffer(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        right: "RIGHT",
        countToken: "COUNT",
        count: number | string
    ]): Result<[key: Buffer, members: Buffer[]] | null, Context>;
    blmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        right: "RIGHT",
        countToken: "COUNT",
        count: number | string
    ]): Result<[key: string, members: string[]] | null, Context>;
    blmpopBuffer(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        right: "RIGHT",
        countToken: "COUNT",
        count: number | string
    ]): Result<[key: Buffer, members: Buffer[]] | null, Context>;
    /**
     * Remove and get the first element in a list, or block until one is available
     * - _group_: list
     * - _complexity_: O(N) where N is the number of provided keys.
     * - _since_: 2.0.0
     */
    blpop(...args: [
        ...keys: RedisKey[],
        timeout: number | string,
        callback: Callback<[string, string] | null>
    ]): Result<[string, string] | null, Context>;
    blpopBuffer(...args: [
        ...keys: RedisKey[],
        timeout: number | string,
        callback: Callback<[Buffer, Buffer] | null>
    ]): Result<[Buffer, Buffer] | null, Context>;
    blpop(...args: [
        keys: RedisKey[],
        timeout: number | string,
        callback: Callback<[string, string] | null>
    ]): Result<[string, string] | null, Context>;
    blpopBuffer(...args: [
        keys: RedisKey[],
        timeout: number | string,
        callback: Callback<[Buffer, Buffer] | null>
    ]): Result<[Buffer, Buffer] | null, Context>;
    blpop(...args: [...keys: RedisKey[], timeout: number | string]): Result<[string, string] | null, Context>;
    blpopBuffer(...args: [...keys: RedisKey[], timeout: number | string]): Result<[Buffer, Buffer] | null, Context>;
    blpop(...args: [keys: RedisKey[], timeout: number | string]): Result<[string, string] | null, Context>;
    blpopBuffer(...args: [keys: RedisKey[], timeout: number | string]): Result<[Buffer, Buffer] | null, Context>;
    /**
     * Remove and get the last element in a list, or block until one is available
     * - _group_: list
     * - _complexity_: O(N) where N is the number of provided keys.
     * - _since_: 2.0.0
     */
    brpop(...args: [
        ...keys: RedisKey[],
        timeout: number | string,
        callback: Callback<[string, string] | null>
    ]): Result<[string, string] | null, Context>;
    brpopBuffer(...args: [
        ...keys: RedisKey[],
        timeout: number | string,
        callback: Callback<[Buffer, Buffer] | null>
    ]): Result<[Buffer, Buffer] | null, Context>;
    brpop(...args: [
        keys: RedisKey[],
        timeout: number | string,
        callback: Callback<[string, string] | null>
    ]): Result<[string, string] | null, Context>;
    brpopBuffer(...args: [
        keys: RedisKey[],
        timeout: number | string,
        callback: Callback<[Buffer, Buffer] | null>
    ]): Result<[Buffer, Buffer] | null, Context>;
    brpop(...args: [...keys: RedisKey[], timeout: number | string]): Result<[string, string] | null, Context>;
    brpopBuffer(...args: [...keys: RedisKey[], timeout: number | string]): Result<[Buffer, Buffer] | null, Context>;
    brpop(...args: [keys: RedisKey[], timeout: number | string]): Result<[string, string] | null, Context>;
    brpopBuffer(...args: [keys: RedisKey[], timeout: number | string]): Result<[Buffer, Buffer] | null, Context>;
    /**
     * Pop an element from a list, push it to another list and return it; or block until one is available
     * - _group_: list
     * - _complexity_: O(1)
     * - _since_: 2.2.0
     */
    brpoplpush(source: RedisKey, destination: RedisKey, timeout: number | string, callback?: Callback<string | null>): Result<string | null, Context>;
    brpoplpushBuffer(source: RedisKey, destination: RedisKey, timeout: number | string, callback?: Callback<Buffer | null>): Result<Buffer | null, Context>;
    /**
     * Remove and return members with scores in a sorted set or block until one is available
     * - _group_: sorted-set
     * - _complexity_: O(K) + O(N*log(M)) where K is the number of provided keys, N being the number of elements in the sorted set, and M being the number of elements popped.
     * - _since_: 7.0.0
     */
    bzmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        min: "MIN",
        callback: Callback<unknown>
    ]): Result<unknown, Context>;
    bzmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        min: "MIN",
        callback: Callback<unknown>
    ]): Result<unknown, Context>;
    bzmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        min: "MIN"
    ]): Result<unknown, Context>;
    bzmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        min: "MIN"
    ]): Result<unknown, Context>;
    bzmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        min: "MIN",
        countToken: "COUNT",
        count: number | string,
        callback: Callback<unknown>
    ]): Result<unknown, Context>;
    bzmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        min: "MIN",
        countToken: "COUNT",
        count: number | string,
        callback: Callback<unknown>
    ]): Result<unknown, Context>;
    bzmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        min: "MIN",
        countToken: "COUNT",
        count: number | string
    ]): Result<unknown, Context>;
    bzmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        min: "MIN",
        countToken: "COUNT",
        count: number | string
    ]): Result<unknown, Context>;
    bzmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        max: "MAX",
        callback: Callback<unknown>
    ]): Result<unknown, Context>;
    bzmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        max: "MAX",
        callback: Callback<unknown>
    ]): Result<unknown, Context>;
    bzmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        max: "MAX"
    ]): Result<unknown, Context>;
    bzmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        max: "MAX"
    ]): Result<unknown, Context>;
    bzmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        max: "MAX",
        countToken: "COUNT",
        count: number | string,
        callback: Callback<unknown>
    ]): Result<unknown, Context>;
    bzmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        max: "MAX",
        countToken: "COUNT",
        count: number | string,
        callback: Callback<unknown>
    ]): Result<unknown, Context>;
    bzmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        ...keys: RedisKey[],
        max: "MAX",
        countToken: "COUNT",
        count: number | string
    ]): Result<unknown, Context>;
    bzmpop(...args: [
        timeout: number | string,
        numkeys: number | string,
        keys: RedisKey[],
        max: "MAX",
        countToken: "COUNT",
        count: number | string
    ]): Result<unknown, Context>;
    /**
     * Remove and return the member with the highest score from one or more sorted sets, or block until one is available
     * - _group_: sorted-set
     * - _complexity_: O(log(N)) with N being the number of elements in the sorted set.
     * - _since_: 5.0.0
     */
    bzpopmax(...args: [
        ...keys: RedisKey[],
        timeout: number | string,
        callback: Callback<[key: string, member: string, score: string] | null>
    ]): Result<[key: string, member: string, score: string] | null, Context>;
    bzpopmaxBuffer(...args: [
        ...keys: RedisKey[],
        timeout: number | string,
        callback: Callback<[key: Buffer, member: Buffer, score: Buffer] | null>
    ]): Result<[key: Buffer, member: Buffer, score: Buffer] | null, Context>;
    bzpopmax(...args: [
        keys: RedisKey[],
        timeout: number | string,
        callback: Callback<[key: string, member: string, score: string] | null>
    ]): Result<[key: string, member: string, score: string] | null, Context>;
    bzpopmaxBuffer(...args: [
        keys: RedisKey[],
        timeout: number | string,
        callback: Callback<[key: Buffer, member: Buffer, score: Buffer] | null>
    ]): Result<[key: Buffer, member: Buffer, score: Buffer] | null, Context>;
    bzpopmax(...args: [...keys: RedisKey[], timeout: number | string]): Result<[key: string, member: string, score: string] | null, Context>;
    bzpopmaxBuffer(...args: [...keys: RedisKey[], timeout: number | string]): Result<[key: Buffer, member: Buffer, score: Buffer] | null, Context>;
    bzpopmax(...args: [keys: RedisKey[], timeout: number | string]): Result<[key: string, member: string, score: string] | null, Context>;
    bzpopmaxBuffer(...args: [keys: RedisKey[], timeout: number | string]): Result<[key: Buffer, member: Buffer, score: Buffer] | null, Context>;
    /**
     * Remove and return the member with the lowest score from one or more sorted sets, or block until one is available
     * - _group_: sorted-set
     * - _complexity_: O(log(N)) with N being the number of elements in the sorted set.
     * - _since_: 5.0.0
     */
    bzpopmin(...args: [
        ...keys: RedisKey[],
        timeout: number | string,
        callback: Callback<[key: string, member: string, score: string] | null>
    ]): Result<[key: string, member: string, score: string] | null, Context>;
    bzpopminBuffer(...args: [
        ...keys: RedisKey[],
        timeout: number | string,
        callback: Callback<[key: Buffer, member: Buffer, score: Buffer] | null>
    ]): Result<[key: Buffer, member: Buffer, score: Buffer] | null, Context>;
    bzpopmin(...args: [
        keys: RedisKey[],
        timeout: number | string,
        callback: Callback<[key: string, member: string, score: string] | null>
    ]): Result<[key: string, member: string, score: string] | null, Context>;
    bzpopminBuffer(...args: [
        keys: RedisKey[],
        timeout: number | string,
        callback: Callback<[key: Buffer, member: Buffer, score: Buffer] | null>
    ]): Result<[key: Buffer, member: Buffer, score: Buffer] | null, Context>;
    bzpopmin(...args: [...keys: RedisKey[], timeout: number | string]): Result<[key: string, member: string, score: string] | null, Context>;
    bzpopminBuffer(...args: [...keys: RedisKey[], timeout: number | string]): Result<[key: Buffer, member: Buffer, score: Buffer] | null, Context>;
    bzpopmin(...args: [keys: RedisKey[], timeout: number | string]): Result<[key: string, member: string, score: string] | null, Context>;
    bzpopminBuffer(...args: [keys: RedisKey[], timeout: number | string]): Result<[key: Buffer, member: Buffer, score: Buffer] | null, Context>;
    /**
     * Instruct the server about tracking or not keys in the next request
     * - _group_: connection
     * - _complexity_: O(1)
     * - _since_: 6.0.0
     */
    client(subcommand: "CACHING", yes: "YES", callback?: Callback<"OK">): Result<"OK", Context>;
    client(subcommand: "CACHING", no: "NO", callback?: Callback<"OK">): Result<"OK", Context>;
    /**
     * Get the current connection name
     * - _group_: connection
     * - _complexity_: O(1)
     * - _since_: 2.6.9
     */
    client(subcommand: "GETNAME", callback?: Callback<string | null>): Result<string | null, Context>;
    clientBuffer(subcommand: "GETNAME", callback?: Callback<Buffer | null>): Result<Buffer | null, Context>;
    /**
     * Get tracking notifications redirection client ID if any
     * - _group_: connection
     * - _complexity_: O(1)
     * - _since_: 6.0.0
     */
    client(subcommand: "GETREDIR", callback?: Callback<number>): Result<number, Context>;
    /**
     * Show helpful text about the different subcommands
     * - _group_: connection
     * - _complexity_: O(1)
     * - _since_: 5.0.0
     */
    client(subcommand: "HELP", callback?: Callback<unknown>): Result<unknown, Context>;
    /**
     * Returns the client ID for the current connection
     * - _group_: connection
     * - _complexity_: O(1)
     * - _since_: 5.0.0
     */
    client(subcommand: "ID", callback?: Callback<number>): Result<number, Context>;
    /**
     * Returns information about the current client connection.
     * - _group_: connection
     * - _complexity_: O(1)
     * - _since_: 6.2.0
     */
    client(subcommand: "INFO", callback?: Callback<string>): Result<string, Context>;
    clientBuffer(subcommand: "INFO", callback?: Callback<Buffer>): Result<Buffer, Context>;
    /**
     * Kill the connection of a client
     * - _group_: connection
     * - _complexity_: O(N) where N is the number of client connections
     * - _since_: 2.4.0
     */
    client(...args: [
        subcommand: "KILL",
        ...args: RedisValue[],
        callback: Callback<unknown>
    ]): Result<unknown, Context>;
    client(...args: [subcommand: "KILL", ...args: RedisValue[]]): Result<unknown, Context>;
    /**
     * Get the list of client connections
     * - _group_: connection
     * - _complexity_: O(N) where N is the number of client connections
     * - _since_: 2.4.0
     */
    client(subcommand: "LIST", callback?: Callback<unknown>): Result<unknown, Context>;
    client(...args: [
        subcommand: "LIST",
        idToken: "ID",
        ...clientIds: (number | string)[],
        callback: Callback<unknown>
    ]): Result<unknown, Context>;
    client(...args: [
        subcommand: "LIST",
        idToken: "ID",
        ...clientIds: (number | string)[]
    ]): Result<unknown, Context>;
    client(subcommand: "LIST", type: "TYPE", normal: "NORMAL", callback?: Callback<unknown>): Result<unknown, Context>;
    client(...args: [
        subcommand: "LIST",
        type: "TYPE",
        normal: "NORMAL",
        idToken: "ID",
        ...clientIds: (number | string)[],
        callback: Callback<unknown>
    ]): Result<unknown, Context>;
    client(...args: [
        subcommand: "LIST",
        type: "TYPE",
        normal: "NORMAL",
        idToken: "ID",
        ...clientIds: (number | string)[]
    ]): Result<unknown, Context>;
    client(subcommand: "LIST", type: "TYPE", master: "MASTER", callback?: Callback<unknown>): Result<unknown, Context>;
    client(...args: [
        subcommand: "LIST",
        type: "TYPE",
        master: "MASTER",
        idToken: "ID",
        ...clientIds: (number | string)[],
        callback: Callback<unknown>
    ]): Result<unknown, Context>;
    client(...args: [
        subcommand: "LIST",
        type: "TYPE",
        master: "MASTER",
        idToken: "ID",
        ...clientIds: (number | string)[]
    ]): Result<unknown, Context>;
    client(subcommand: "LIST", type: "TYPE", replica: "REPLICA", callback?: Callback<unknown>): Result<unknown, Context>;
    client(...args: [
        subcommand: "LIST",
        type: "TYPE",
        replica: "REPLICA",
        idToken: "ID",
        ...clientIds: (number | string)[],
        callback: Callback<unknown>
    ]): Result<unknown, Context>;
    client(...args: [
        subcommand: "LIST",
        type: "TYPE",
        replica: "REPLICA",
        idToken: "ID",
        ...clientIds: (number | string)[]
    ]): Result<unknown, Context>;
    client(subcommand: "LIST", type: "TYPE", pubsub: "PUBSUB", callback?: Callback<unknown>): Result<unknown, Context>;
    client(...args: [
        subcommand: "LIST",
        type: "TYPE",
        pubsub: "PUBSUB",
        idToken: "ID",
        ...clientIds: (number | string)[],
        callback: Callback<unknown>
    ]): Result<unknown, Context>;
    client(...args: [
        subcommand: "LIST",
        type: "TYPE",
        pubsub: "PUBSUB",
        idToken: "ID",
        ...clientIds: (number | string)[]
    ]): Result<unknown, Context>;
    /**
     * Set client eviction mode for the current connection
     * - _group_: connection
     * - _complexity_: O(1)
     * - _since_: 7.0.0
     */
    client(subcommand: "NO-EVICT", on: "ON", callback?: Callback<unknown>): Result<unknown, Context>;
    client(subcommand: "NO-EVICT", off: "OFF", callback?: Callback<unknown>): Result<unknown, Context>;
    /**
     * Stop processing commands from clients for some time
     * - _group_: connection
     * - _complexity_: O(1)
     * - _since_: 2.9.50
     */
    client(subcommand: "PAUSE", timeout: number | string, callback?: Callback<"OK">): Result<"OK", Context>;
    client(subcommand: "PAUSE", timeout: number | string, write: "WRITE", callback?: Callback<"OK">): Result<"OK", Context>;
    client(subcommand: "PAUSE", timeout: number | string, all: "ALL", callback?: Callback<"OK">): Result<"OK", Context>;
    /**
     * Instruct the server whether to reply to commands
     * - _group_: connection
     * - _complexity_: O(1)
     * - _since_: 3.2.0
     */
    client(subcommand: "REPLY", on: "ON", callback?: Callback<unknown>): Result<unknown, Context>;
    client(subcommand: "REPLY", off: "OFF", callback?: Callback<unknown>): Result<unknown, Context>;
    client(subcommand: "REPLY", skip: "SKIP", callback?: Callback<unknown>): Result<unknown, Context>;
    /**
     * Set the current connection name
     * - _group_: connection
     * - _complexity_: O(1)
     * - _since_: 2.6.9
     */
    client(subcommand: "SETNAME", connectionName: string | Buffer, callback?: Callback<"OK">): Result<"OK", Context>;
    /**
     * Enable or disable server assisted client side caching support
     * - _group_: connection
     * - _complexity_: O(1). Some options may introduce additional complexity.
     * - _since_: 6.0.0
     */
    client(...args: [
        subcommand: "TRACKING",
        ...args: RedisValue[],
        callback: Callback<unknown>
    ]): Result<unknown, Context>;
    client(...args: [subcommand: "TRACKING", ...args: RedisValue[]]): Result<unknown, Context>;
    /**
     * Return information about server assisted client side caching for the current connection
     * - _group_: connection
     * - _complexity_: O(1)
     * - _since_: 6.2.0
     */
    client(subcommand: "TRACKINGINFO", callback?: Callback<string>): Result<string, Context>;
    clientBuffer(subcommand: "TRACKINGINFO", callback?: Callback<Buffer>): Result<Buffer, Context>;
    /**
     * Unblock a client blocked in a blocking command from a different connection
     * - _group_: connection
     * - _complexity_: O(log N) where N is the number of client connections
     * - _since_: 5.0.0
     */
    client(subcommand: "UNBLOCK", clientId: number | string, callback?: Callback<unknown>): Result<unknown, Context>;
    client(subcommand: "UNBLOCK", clientId: number | string, timeout: "TIMEOUT", callback?: Callback<unknown>): Result<unknown, Context>;
    client(subcommand: "UNBLOCK", clientId: number | string, error: "ERROR", callback?: Callback<unknown>): Result<unknown, Context>;
    /**
     * Resume processing of clients that were paused
     * - _group_: connection
     * - _complexity_: O(N) Where N is the number of paused clients
     * - _since_: 6.2.0
     */
    client(subcommand: "UNPAUSE", callback?: Callback<"OK">): Result<"OK", Context>;
    /**
     * Assign new hash slots to receiving node
     * - _group_: cluster
     * - _complexity_: O(N) where N is the total number of hash slot arguments
     * - _since_: 3.0.0
     */
    cluster(...args: [
        subcommand: "ADDSLOTS",
        ...slots: (number | string)[],
        callback: Callback<[
            startSlotRange: number,
            endSlotRange: number,
            ...nodes: [
                host: string,
                port: number,
                nodeId: string,
                info: unknown[]
            ][]
        ][]>
    ]): Result<[
        startSlotRange: number,
        endSlotRange: number,
        ...nodes: [host: string, port: number, nodeId: string, info: unknown[]][]
    ][], Context>;
    cluster(...args: [
        subcommand: "ADDSLOTS",
        slots: (number | string)[],
        callback: Callback<[
            startSlotRange: number,
            endSlotRange: number,
            ...nodes: [
                host: string,
                port: number,
                nodeId: string,
                info: unknown[]
            ][]
        ][]>
    ]): Result<[
        startSlotRange: number,
        endSlotRange: number,
        ...nodes: [host: string, port: number, nodeId: string, info: unknown[]][]
    ][], Context>;
    cluster(...args: [subcommand: "ADDSLOTS", ...slots: (number | string)[]]): Result<[
        startSlotRange: number,
        endSlotRange: number,
        ...nodes: [host: string, port: number, nodeId: string, info: unknown[]][]
    ][], Context>;
    cluster(...args: [subcommand: "ADDSLOTS", slots: (number | string)[]]): Result<[
        startSlotRange: number,
        endSlotRange: number,
        ...nodes: [host: string, port: number, nodeId: string, info: unknown[]][]
    ][], Context>;
    /**
     * Assign new hash slots to receiving node
     * - _group_: cluster
     * - _complexity_: O(N) where N is the total number of the slots between the start slot and end slot arguments.
     * - _since_: 7.0.0
     */
    cluster(...args: [
        subcommand: "ADDSLOTSRANGE",
        ...startSlotEndSlots: (string | number)[],
        callback: Callback<[
            startSlotRange: number,
            endSlotRange: number,
            ...nodes: [
                host: string,
                port: number,
                nodeId: string,
                info: unknown[]
            ][]
        ][]>
    ]): Result<[
        startSlotRange: number,
        endSlotRange: number,
        ...nodes: [host: string, port: number, nodeId: string, info: unknown[]][]
    ][], Context>;
    cluster(...args: [
        subcommand: "ADDSLOTSRANGE",
        ...startSlotEndSlots: (string | number)[]
    ]): Result<[
        startSlotRange: number,
        endSlotRange: number,
        ...nodes: [host: string, port: number, nodeId: string, info: unknown[]][]
    ][], Context>;
    /**
     * Advance the cluster config epoch
     * - _group_: cluster
     * - _complexity_: O(1)
     * - _since_: 3.0.0
     */
    cluster(subcommand: "BUMPEPOCH", callback?: Callback<"BUMPED" | "STILL">): Result<"BUMPED" | "STILL", Context>;
    /**
     * Return the number of failure reports active for a given node
     * - _group_: cluster
     * - _complexity_: O(N) where N is the number of failure reports
     * - _since_: 3.0.0
     */
    cluster(subcommand: "COUNT-FAILURE-REPORTS", nodeId: string | Buffer | number, callback?: Callback<number>): Result<number, Context>;
    /**
     * Return the number of local keys in the specified hash slot
     * - _group_: cluster
     * - _complexity_: O(1)
     * - _since_: 3.0.0
     */
    cluster(subcommand: "COUNTKEYSINSLOT", slot: number | string, callback?: Callback<number>): Result<number, Context>;
    /**
     * Set hash slots as unbound in receiving node
     * - _group_: cluster
     * - _complexity_: O(N) where N is the total number of hash slot arguments
     * - _since_: 3.0.0
     */
    cluster(...args: [
        subcommand: "DELSLOTS",
        ...slots: (number | string)[],
        callback: Callback<[
            startSlotRange: number,
            endSlotRange: number,
            ...nodes: [
                host: string,
                port: number,
                nodeId: string,
                info: unknown[]
            ][]
        ][]>
    ]): Result<[
        startSlotRange: number,
        endSlotRange: number,
        ...nodes: [host: string, port: number, nodeId: string, info: unknown[]][]
    ][], Context>;
    cluster(...args: [
        subcommand: "DELSLOTS",
        slots: (number | string)[],
        callback: Callback<[
            startSlotRange: number,
            endSlotRange: number,
            ...nodes: [
                host: string,
                port: number,
                nodeId: string,
                info: unknown[]
            ][]
        ][]>
    ]): Result<[
        startSlotRange: number,
        endSlotRange: number,
        ...nodes: [host: string, port: number, nodeId: string, info: unknown[]][]
    ][], Context>;
    cluster(...args: [subcommand: "DELSLOTS", ...slots: (number | string)[]]): Result<[
        startSlotRange: number,
        endSlotRange: number,
        ...nodes: [host: string, port: number, nodeId: string, info: unknown[]][]
    ][], Context>;
    cluster(...args: [subcommand: "DELSLOTS", slots: (number | string)[]]): Result<[
        startSlotRange: number,
        endSlotRange: number,
        ...nodes: [host: string, port: number, nodeId: string, info: unknown[]][]
    ][], Context>;
    /**
     * Set hash slots as unbound in receiving node
     * - _group_: cluster
     * - _complexity_: O(N) where N is the total number of the slots between the start slot and end slot arguments.
     * - _since_: 7.0.0
     */
    cluster(...args: [
        subcommand: "DELSLOTSRANGE",
        ...startSlotEndSlots: (string | number)[],
        callback: Callback<[
            startSlotRange: number,
            endSlotRange: number,
            ...nodes: [
                host: string,
                port: number,
                nodeId: string,
                info: unknown[]
            ][]
        ][]>
    ]): Result<[
        startSlotRange: number,
        endSlotRange: number,
        ...nodes: [host: string, port: number, nodeId: string, info: unknown[]][]
    ][], Context>;
    cluster(...args: [
        subcommand: "DELSLOTSRANGE",
        ...startSlotEndSlots: (string | number)[]
    ]): Result<[
        startSlotRange: number,
        endSlotRange: number,
        ...nodes: [host: string, port: number, nodeId: string, info: unknown[]][]
    ][], Context>;
    /**
     * Forces a replica to perform a manual failover of its master.
     * - _group_: cluster
     * - _complexity_: O(1)
     * - _since_: 3.0.0
     */
    cluster(subcommand: "FAILOVER", callback?: Callback<"OK">): Result<"OK", Context>;
    cluster(subcommand: "FAILOVER", force: "FORCE", callback?: Callback<"OK">): Result<"OK", Context>;
    cluster(subcommand: "FAILOVER", takeover: "TAKEOVER", callback?: Callback<"OK">): Result<"OK", Context>;
    /**
     * Delete a node's own slots information
     * - _group_: cluster
     * - _complexity_: O(1)
     * - _since_: 3.0.0
     */
    cluster(subcommand: "FLUSHSLOTS", callback?: Callback<[
        startSlotRange: number,
        endSlotRange: number,
        ...nodes: [
            host: string,
            port: number,
            nodeId: string,
            info: unknown[]
        ][]
    ][]>): Result<[
        startSlotRange: number,
        endSlotRange: number,
        ...nodes: [host: string, port: number, nodeId: string, info: unknown[]][]
    ][], Context>;
    /**
     * Remove a node from the nodes table
     * - _group_: cluster
     * - _complexity_: O(1)
     * - _since_: 3.0.0
     */
    cluster(subcommand: "FORGET", nodeId: string | Buffer | number, callback?: Callback<"OK">): Result<"OK", Context>;
    /**
     * Return local key names in the specified hash slot
     * - _group_: cluster
     * - _complexity_: O(log(N)) where N is the number of requested keys
     * - _since_: 3.0.0
     */
    cluster(subcommand: "GETKEYSINSLOT", slot: number | string, count: number | string, callback?: Callback<string[]>): Result<string[], Context>;
    /**
     * Show helpful text about the different subcommands
     * - _group_: cluster
     * - _complexity_: O(1)
     * - _since_: 5.0.0
     */
    cluster(subcommand: "HELP", callback?: Callback<unknown>): Result<unknown, Context>;
    /**
     * Provides info about Redis Cluster node state
     * - _group_: cluster
     * - _complexity_: O(1)
     * - _since_: 3.0.0
     */
    cluster(subcommand: "INFO", callback?: Callback<string>): Result<string, Context>;
    /**
     * Returns the hash slot of the specified key
     * - _group_: cluster
     * - _complexity_: O(N) where N is the number of bytes in the key
     * - _since_: 3.0.0
     */
    cluster(subcommand: "KEYSLOT", key: string | Buffer, callback?: Callback<number>): Result<number, Context>;
    /**
     * Returns a list of all TCP links to and from peer node